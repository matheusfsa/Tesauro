Package tesauro;

Helpers
 all = [0 .. 0xFFFF];
 digito = ['0' .. '9'];
 bin = ['0' + '1'];
 letra =[['a'..'z']+['A' .. 'Z']];
 number = digito+;
 espaco = ' ';
 tab = 9;
 cr = 13;
 lf = 10;
 eol = cr lf | cr | lf;
 not_cr_lf = [all - [cr + lf]];
 not_squotes = [all - '''];
 not_dquotes = [all - '"'];
 not_rcbrack = [all - '}'];
 exp = 'E'('-')?number;

Tokens
 /*Palavras reservadas*/
 code = 'code';
 symbol = 'symbol';
 real = 'real';
 integer = 'integer';
 start = 'start';
 finish = 'finish';
 vector = 'vector';
 const = 'unalterable';
 in_case_that = 'in'(espaco | tab | eol)+'case'(espaco | tab | eol)+'that';
 as_long_as = 'as'(espaco | tab | eol)+'long'(espaco | tab | eol)+'as';
 considering = 'considering';
 show = 'show';
 capture = 'capture';
 else = 'else';
 do = 'do';
 from = 'from';
 to = 'to';
 by = 'by'; 
 
 

 /*Valores dos tipos*/

 sym_val = ''' not_squotes ''';
 sym_vec_val =  '"' not_dquotes* '"';
 real_val = ('-')?number'.'number(exp)?;
 int_val = ('-')?('d')?number|('-')?'b'bin+;
 
 /*Comentarios*/

 comment = '{' not_rcbrack* '}';

 /*Operadores*/

 plus = '+';
 minus = '-';
 mult = '*';
 div = '/';
 mod = '%';
 menor = '<';
 maior = '>';
 maior_i = '>=';
 menor_i = '<=';
 igual = '==';
 diff = '!=';
 att = ':=';
 att_const = '=';
 not = '!';
 and = 'and';
 or = 'or';
 xor = 'xor';

 

 /*Delimitadores*/
 l_par = '(';
 r_par = ')';
 l_colch = '[';
 r_colch = ']';
 l_chav = '{';
 r_chav = '}';
 p_v = ';';
 comma = ',';
 
 /*Outros*/

 id = letra(letra|'_')*;
 blank = (espaco | tab | eol)+;

Ignored Tokens
 blank, comment;
 
Productions
	programa = code id bloco;
	
	bloco = start declaracao* cmd* finish;
	
	declaracao = {var} tipo id_comma* id p_v
		| {constante} const tipo id p_v
		| {const_att} const tipo id att_const valor p_v;
	
	
	cmd = {cmd_sem_coisa} cmd_sem_coisa	
		| {ict_do}	ict_do
		| {ict_do_else}	ict_do_else
		| {iteration_cmd} iteration_cmd
		| {bloco} bloco;
		
	cmd_no_short_ict = {cmd_sem_coisa} cmd_sem_coisa 
		| {ict_do_else_no_if}	ict_do_else_no_short_ict
		| {iteration_cmd_no_if}	iteration_cmd_no_short_ict
		| {bloco} bloco;	
		
	cmd_sem_coisa = {att_cmd}	att_cmd
		| {func_cmd}	func_cmd;
		
	ict_do = in_case_that l_par exp r_par do cmd;
	
	ict_do_else = in_case_that l_par exp r_par do cmd_no_short_ict else cmd;
	
	ict_do_else_no_short_ict = in_case_that l_par exp r_par do [cmd1]:cmd_no_short_ict else [cmd2]:cmd_no_short_ict;
	
	
	att_cmd = {var} var att exp p_v
		| {const} const var att_const exp p_v;
		
	func_cmd = {capture} capture l_par var_comma* var r_par p_v
		| {show} show l_par exp_comma* exp r_par p_v;
		
	iteration_cmd = {as_long_as} as_long_as l_par exp r_par do cmd
		| {considering} considering var from [ini]:exp to [fim]:exp by [inc]:exp do cmd;
		
	iteration_cmd_no_short_ict = {as_long_as} as_long_as l_par exp r_par do cmd_no_short_ict
		| {considering} considering var from [ini]:exp to [fim]:exp by [inc]:exp do cmd_no_short_ict;
					
	var_comma = var comma;	
	
	exp_comma = exp comma;	
			
	exp = or_op;
	
	or_op = {and_op} and_op
		| {or} or_op or and_op;
		
	and_op = {xor_op} xor_op
		| {and} and_op and xor_op; 
		
	xor_op = {eq_op} eq_op
		| {xor} xor_op xor eq_op; 
	
	eq_op = {rel_op} rel_op
		| {igual} eq_op igual rel_op
		| {diff} eq_op diff rel_op;
		
	rel_op = {op} op
		| {maior} rel_op maior op
		| {menor} rel_op menor op
		| {maior_i} rel_op maior_i op
		| {menor_i} rel_op menor_i op;
		
	op = {fator} fator
		| {sum} op plus fator
		| {minus} op minus fator;
		

	fator = {termo} termo 
  		| {mult} fator mult termo 
  		| {div} fator div termo 
  		| {mod} fator mod termo
  		| {min_un} minus termo
  		| {not} not termo;
  	
  	termo = {valor} valor 
  		| {var} var
  		| {par} l_par exp r_par;
		

	var = id var_vec*;
	
	tipo_base = {symbol} symbol 
			| {real} real
			| {integer} integer;
			
	tipo = {simples} tipo_base
		| {composto} tipo_base vector;
		
	id_comma = id comma;
	
	tipo_vec = l_colch exp r_colch;
	
	vec_tipo = vector [obr]:tipo_vec [opc]: tipo_vec*;
	
	var_vec = {var_vec} l_colch int_val r_colch;
	
	valor = {sym} sym_val 
		| {real} real_val
		| {int} int_val 
		| {string} sym_vec_val;
		

